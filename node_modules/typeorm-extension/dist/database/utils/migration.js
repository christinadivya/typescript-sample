"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateMigration = void 0;
const pascal_case_1 = require("pascal-case");
const node_path_1 = __importDefault(require("node:path"));
const node_fs_1 = __importDefault(require("node:fs"));
const node_process_1 = __importDefault(require("node:process"));
const MigrationGenerateCommand_1 = require("typeorm/commands/MigrationGenerateCommand");
class GenerateCommand extends MigrationGenerateCommand_1.MigrationGenerateCommand {
    static prettify(query) {
        return this.prettifyQuery(query);
    }
}
function queryParams(parameters) {
    if (!parameters || !parameters.length) {
        return '';
    }
    return `, ${JSON.stringify(parameters)}`;
}
function buildTemplate(name, timestamp, upStatements, downStatements) {
    const migrationName = `${(0, pascal_case_1.pascalCase)(name)}${timestamp}`;
    const up = upStatements.map((statement) => `        ${statement}`);
    const down = downStatements.map((statement) => `        ${statement}`);
    return `import { MigrationInterface, QueryRunner } from 'typeorm';

export class ${migrationName} implements MigrationInterface {
    name = '${migrationName}';

    public async up(queryRunner: QueryRunner): Promise<void> {
${up.join(`
`)}
    }
    public async down(queryRunner: QueryRunner): Promise<void> {
${down.join(`
`)}
    }
}
`;
}
async function generateMigration(context) {
    context.name = context.name || 'Default';
    const timestamp = context.timestamp || new Date().getTime();
    const fileName = `${timestamp}-${context.name}.ts`;
    const { dataSource } = context;
    const up = [];
    const down = [];
    if (!dataSource.isInitialized) {
        await dataSource.initialize();
    }
    const sqlInMemory = await dataSource.driver.createSchemaBuilder().log();
    if (context.prettify) {
        sqlInMemory.upQueries.forEach((upQuery) => {
            upQuery.query = GenerateCommand.prettify(upQuery.query);
        });
        sqlInMemory.downQueries.forEach((downQuery) => {
            downQuery.query = GenerateCommand.prettify(downQuery.query);
        });
    }
    sqlInMemory.upQueries.forEach((upQuery) => {
        up.push(`await queryRunner.query(\`${upQuery.query.replace(/`/g, '\\`')}\`${queryParams(upQuery.parameters)});`);
    });
    sqlInMemory.downQueries.forEach((downQuery) => {
        down.push(`await queryRunner.query(\`${downQuery.query.replace(/`/g, '\\`')}\`${queryParams(downQuery.parameters)});`);
    });
    await dataSource.destroy();
    if (up.length === 0 &&
        down.length === 0) {
        return { up, down };
    }
    const content = buildTemplate(context.name, timestamp, up, down.reverse());
    if (!context.preview) {
        let directoryPath;
        if (context.directoryPath) {
            if (!node_path_1.default.isAbsolute(context.directoryPath)) {
                directoryPath = node_path_1.default.join(node_process_1.default.cwd(), context.directoryPath);
            }
            else {
                directoryPath = context.directoryPath;
            }
        }
        else {
            directoryPath = node_path_1.default.join(node_process_1.default.cwd(), 'migrations');
        }
        try {
            await node_fs_1.default.promises.access(directoryPath, node_fs_1.default.constants.R_OK | node_fs_1.default.constants.W_OK);
        }
        catch (e) {
            await node_fs_1.default.promises.mkdir(directoryPath, { recursive: true });
        }
        const filePath = node_path_1.default.join(directoryPath, fileName);
        await node_fs_1.default.promises.writeFile(filePath, content, { encoding: 'utf-8' });
    }
    return {
        up,
        down,
        content,
    };
}
exports.generateMigration = generateMigration;
